#!/usr/bin/env perl

package RUM::Script::Pipeline;

use strict;
use warnings;

use Getopt::Long;
use FindBin qw($Bin);
use lib "$Bin/../lib";

use RUM::ChunkMachine;
use RUM::Repository;
use RUM::Usage;
use RUM::Logging;
use RUM::Pipeline;
use File::Path qw(mkpath);

our $log = RUM::Logging->get_logger("RUM::UI");

our $LOGO;

sub DEBUG  { $log->debug(wrap("", "", @_))  }
sub INFO   { $log->info(wrap("", "", @_))   }
sub WARN   { $log->warn(wrap("", "", @_))   }
sub ERROR  { $log->error(wrap("", "", @_))  }
sub FATAL  { $log->fatal(wrap("", "", @_))  }
sub LOGDIE { $log->logdie(wrap("", "", @_)) }

sub main {

    GetOptions(

        "version"   => \(my $do_version),
        "kill"      => \(my $do_kill),
        "postprocess" => \(my $do_postprocess),

        "config=s"    => \(my $rum_config_file),
        "forward=s"   => \(my $forward),
        "reverse=s"   => \(my $reverse),
        "output|o=s"  => \(my $output_dir),
        "name=s"      => \(my $name),
        "chunks=s"    => \(my $num_chunks = 1),
        "help"        => sub { RUM::Usage->help },
        "help-config" => \(my $do_help_config),
        "read-lengths=s" => \(my $read_lengths),

        "max-insertions-per-read=s" => \(my $num_insertions_allowed),
        "strand-specific" => \(my $strand_specific),
        "ram" => \(my $ram = 6),
        "preserve-names" => \(my $preserve_names),
        "no-clean" => \(my $no_clean),
        "junctions" => \(my $junctions),
        "blat-only" => \(my $blat_only),
        "quantify" => \(my $quantify),
        "count-mismatches" => \(my $count_mismatches),
        "variable-read-lengths|variable-length-reads" => \(my $variable_read_lengths),
        "dna" => \(my $dna),
        "genome-only" => \(my $genome_only),

        "limit-bowtie-nu" => \(my $limit_bowtie_nu),
        "limit-nu=s" => \(my $nu_limit),
        "qsub" => \(my $qsub),
        "alt-genes=s" => \(my $alt_genes),
        "alt-quants=s" => \(my $alt_quant),

        "min-identity" => \(my $min_identity = 93),


        "tileSize=s" => \(my $tile_size = 12),
        "stepSize=s" => \(my $step_size = 6),
        "repMatch=s" => \(my $rep_match = 256),
        "maxIntron=s" => \(my $max_intron = 500000),

        "min-length=s" => \(my $min_length),

        "quals-file|qual-file=s" => \(my $quals_file),
        "verbose|v"   => sub { $log->more_logging(1) },
        "quiet|q"     => sub { $log->less_logging(1) }
    );

    if ($do_version) {
        print "RUM version $RUM::Pipeline::VERSION, released $RUM::Pipeline::RELEASE_DATE\n";
        return;
    }
    if ($do_help_config) {
        print $RUM::ChunkConfig::CONFIG_DESC;
        return;
    }

    !defined($quals_file) || $quals_file =~ /\// or RUM::Usage->bad(
        "do not specify -quals file with a full path, put it in the '$output_dir' directory.");
    
    $min_identity =~ /^\d+$/ && $min_identity <= 100 or RUM::Usage->bad(
        "--min-identity must be an integer between zero and 100. You
        have given '$min_identity'.");

    if (defined($min_length)) {
        $min_length =~ /^\d+$/ && $min_length >= 10 or RUM::Usage->bad(
            "--min-length must be an integer >= 10. You have given '$min_length'.");
    }
    
    if (defined($nu_limit)) {
        $nu_limit =~ /^\d+$/ && $nu_limit > 0 or RUM::Usage->bad(
            "--limit-nu must be an integer greater than zero.\nYou have given '$nu_limit'.");
    }

    $preserve_names && $variable_read_lengths and RUM::Usage->bad(
        "Cannot use both -preserve_names and -variable_read_lengths at the same time.\nSorry, we will fix this eventually.");

    if ($alt_genes) {
        -r $alt_genes or die "Can't read from $alt_genes: $!";
    }
    if ($alt_quant) {
        -r $alt_quant or die "Can't read from $alt_quant: $!";
    }

    $rum_config_file or RUM::Usage->bad(
        "Please specify a rum config file with --config");

    $output_dir or RUM::Usage->bad(
        "Please specify an output directory with --output or -o");

    $name or RUM::Usage->bad(
        "Please provide a name with --name");
    $name = fix_name($name);

    unless (-d $output_dir) {
        mkpath($output_dir) or die "mkdir $output_dir: $!";
    }

print <<EOF;

RUM Version $RUM::Pipeline::VERSION

$LOGO
EOF


    for my $chunk_num (1 .. $num_chunks) {
        my $config = RUM::ChunkConfig->new(config_file => $rum_config_file,
                                           forward     => $forward,
                                           chunk       => $chunk_num,
                                           output_dir  => $output_dir,
                                           paired_end  => $reverse ? 1 : 0);
    }

}

sub fix_name {

    my ($name) = @_;

    my $name_o = $name;
    $name =~ s/\s+/_/g;
    $name =~ s/^[^a-zA-Z0-9_.-]//;
    $name =~ s/[^a-zA-Z0-9_.-]$//g;
    $name =~ s/[^a-zA-Z0-9_.-]/_/g;
    
    if($name ne $name_o) {
        WARN("Name changed from '$name_o' to '$name'.");
        if(length($name) > 250) {
            LOGDIE("The name must be less than 250 characters.");
        }
    }
    return $name;
}

sub check_gamma {
    my ($self) = @_;
    my $host = `hostname`;
    if ($host =~ /login.genomics.upenn.edu/ && !$self->config->qsub) {
        LOGDIE("you cannot run RUM on the PGFI cluster without using the --qsub option.");
    }
}

$LOGO = <<'EOF';
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 _   _   _   _   _   _    _
               // \// \// \// \// \// \/
              //\_//\_//\_//\_//\_//\_//
        o_O__O_ o
       | ====== |       .-----------.
       `--------'       |||||||||||||
        || ~~ ||        |-----------|
        || ~~ ||        | .-------. |
        ||----||        ! | UPENN | !
       //      \\        \`-------'/
      // /!  !\ \\        \_  O  _/
     !!__________!!         \   /
     ||  ~~~~~~  ||          `-'
     || _        ||
     |||_|| ||\/|||
     ||| \|_||  |||
     ||          ||
     ||  ~~~~~~  ||
     ||__________||
.----|||        |||------------------.
     ||\\      //||                 /|
     |============|                //
     `------------'               //
---------------------------------'/
---------------------------------'
  ____________________________________________________________
- The RNA-Seq Unified Mapper (RUM) Pipeline has been initiated -
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
EOF

__PACKAGE__->main();


=pod

=head1 NAME

RUM_runner

=head1 SYNOPSIS

  RUM_runner.pl [OPTIONS] --config <config_file> --forward <forward_reads> [--reverse <reverse_reads>] -o <output_dir> --name <name>
  RUM_runner.pl --help
  RUM_runner.pl --version
  RUM_runner.pl --kill
  RUM_runner.pl --status 

=head1 DESCRIPTION

  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  RUM version: $version
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                   _   _   _   _   _   _
                 // \\// \\// \\// \\// \\// \\/
                //\\_//\\_//\\_//\\_//\\_//\\_//
          o_O__O_ o
         | ====== |       .-----------.
         `--------'       |||||||||||||
          || ~~ ||        |-----------|
          || ~~ ||        | .-------. |
          ||----||        ! | UPENN | !
         //      \\        \`-------'/
        // /!  !\ \\        \_  O  _/
       !!__________!!         \   /
       ||  ~~~~~~  ||          `-'
       || _        ||
       |||_|| ||\/|||
       ||| \|_||  |||
       ||          ||
       ||  ~~~~~~  ||
       ||__________||
  .----|||        |||------------------.
       ||\\      //||                 /|
       |============|                //
       `------------'               //
  ---------------------------------'/
  ---------------------------------'
    .------------------------------------.
    | RNA-Seq Unified Mapper (RUM) Usage |
    ` ================================== '

=head1 OPTIONS

=over 4

=item B<--config> I<config_file>

This file tells RUM where to find the various executables and indexes.
This file is included in the 'lib' directory when you download an
organism, for example rum.config_mm9 for mouse build mm9, which will
work if you leave everything in its default location.  To modify or
make your own config file, run this program with the single argument
'config' for more information on the config file.

=item B<-o>, B<--output-dir> I<output_dir>

Where to write the temp, interemediate, and results files.

=item B<--chunks> I<num_chunks>

The number of pieces to break the job into.  Use one chunk unless you
are on a cluster, or have multiple cores with lots of RAM.  Have at
least one processing core per chunk.  A genome like human will also
need about 5 to 6 Gb of RAM per chunk.  Even with a small genome, if
you have tens of millions of reads, you will still need a few Gb of
RAM to get through the post-processing.

=item B<--name> I<name>

A string to identify this run - use only alphanumeric, underscores,
and dashes.  No whitespace or other characters.  Must be less than 250
characters.

=back

Usage: RUM_runner.pl <config file> <reads file(s)> <output dir> <num chunks>
                     <name> [options]



<reads file(s)> :  1) For unpaired data, the single file of reads.
                   2) For paired data the files of forward and reverse reads,
                      separated by three commas ',,,' (with no spaces).

                   NOTE ON FILE FORMATS: Files can be either fasta or fastq,
                   the type is inferred.

Options: There are many options, but RUM is typically run with the defaults. The
         option -kill is also quite useful to stop a run, because killing just
         the main program will not always kill the spawned processes.



=item B<--strand-specific>

If the data are strand specific, then you can use this option to
generate strand specific coverage plots and quantified values.

=item B<--dna>

Run in dna mode, meaning don't map across splice junctions.

=item B<--genome-only>

Do RNA mapping, but without using a transcript database.  Note: there
will be no feature quantifications in this mode, because those are
based on the transcript database.

=item B<--variable-read-lengths>

Set this if your reads are not all of the same length.

=item B<--limit-nu> I<n>

Limits the number of ambiguous mappers in the final output by removing
all reads that map to n locations or more.

=item B<--limit-bowtie-nu>

Limits the number of ambiguous mappers in the Bowtie run to a max of
100.  If you have short reads and a large genome, or a very repetitive
genome, this might be necessary to keep the bowtie files from getting
out of hand - 10Gb per lane is not abnormal but 100Gb might be. (note:
45 bases is considered short for mouse, 70 bases considered long,
between it's hard to say).

=item B<--quantify>

Use this *if* using the -dna flag and you still want quantified
features.  If this is set you *must* have the gene models file
specified in the rum config file.  Without the -dna flag quantified
features are generated by default so you don't need to set this.

=item B<--junctions>

Use this *if* using the -dna flag and you still want junction
calls. If this is set you should have the gene models file specified
in the rum config file (if you have one).  Without the -dna flag
junctions generated by default so you don't need to set this.

=item B<--min-length> I<x>

Don't report alignments less than this long.  The default = 50 if the
readlength >= 80, else = 35 if readlength >= 45 else = 0.8 *
readlength.  Don't set this too low you will start to pick up a lot of
garbage.

=item B<--count-mismatches>

Report in the last column the number of mismatches, ignoring
insertions

=item B<--alt-genes> I<x>

x is a file with gene models to use for calling junctions novel.  If
not specified will use the gene models file specified in the config
file.

=item B<--alt-quant> I<x>

If specified x will be used to quantify features in addition to the
gene models file specified in the config file.  Both are reported to
separate files.

=item B<--qsub>

Use qsub to fire the job off to multiple nodes on a cluster.  This
means you're on a cluster that understands qsub like the Sun Grid
Engine.

Note: without using -qsub, you can still specify more than one chunk.
It should fire each chunk off to a separate core.  But don't use more
chunks than you have cores, because that can slow things down
considerably.

=item B<--max-insertions-per-read> I<n>

Allow at most n insertions in one read.  The default is n=1.  Setting
n>1 is only allowed for single end reads.  Don't raise it unless you
know what you are doing, because it can greatly increase the false
alignments.

=item B<--no-clean>

Do not remove the intermediate and temp files after finishing.

=item B<--preserve-names>

Keep the original read names in the SAM output file.  Note: this
doesn't work when there are variable length reads.

=item B<--ram> I<n>

On some systems RUM might not be able to determine the amount of RAM
you have.  In that case, with this option you can specify the number
of Gb of ram you want to dedicate to each chunk.  This is rarely
necessary and never necessary if you have at least 6 Gb per chunk.

=head2 Commands

=item B<--kill>

To kill a job, run with all the same parameters but add -kill.  Note:
it is not sufficient to just terminate RUM_runner.pl, that will leave
other phantom processes.  Use -kill instead.

=item B<-V>, B<--version>

Returns the current version.

=head2 BLAT options

You can tweak the BLAT portion of RUM to suit your needs. We found the
following to be a good balance for speed, sensitivity, and temporary
file size.

=item B<--minIdentity> I<x>

Run blat with minIdentity=x (default x=93). You shouldn't need to
change this.

=item B<--tileSize> I<x>

Run blat with tileSize=x (default x=12). You shouldn't need to change
this.

=item B<--stepSize> I<x>

Run blat with stepSize=x (default x=6).  You shouldn't need to change
this.

=item B<--repMatch> I<x>

Run blat with repMatch=x (default x=256).  You shouldn't need to
change this.

=item B<--maxIntron> I<x>

Run blat with maxIntron=x (default x=50000).  You shouldn't need to
change this.



Default config files are supplied with each organism.  If you need to make or
modify one then running RUM_runner.pl with the one argument 'config' gives an
explaination of the the file.

This program writes very large intermediate files.  If you have a large genome
such as mouse or human then it is recommended to run in chunks on a cluster, or
a machine with multiple processors.  Running with under five million reads per
chunk is usually best, and getting it under a million reads per chunk will speed
things considerably.

You can put an 's' after the number of chunks if they have already been broken
into chunks, so as to avoid repeating this time-consuming step.

=cut
