#!/usr/bin/env perl

BEGIN {

    my @modules = qw(autodie);
    my %errors;
    for my $module (@modules) {
        my $file = $module . ".pm";
        $file =~ s/::/\//g;

        eval {
            require $file;
        };
        if ($@) {
            warn "$@\n";
            $errors{$module} = $@;
        }
    }
    if (keys %errors) {
        my $msg = "";
        $msg .= "There were some dependencies I couldn't find.\n";
        $msg .= "Please make sure the following libraries are installed:\n";
        for my $error (keys %errors) {
            $msg .= "  * $error\n";
        }
        die "$msg\n";
    }
}


use strict;
use warnings;

use FindBin qw($Bin);
use lib ("$Bin/../lib", "$Bin/../lib/perl5");

use RUM::Logging;

# Initialize the logging system. We only want to log if the action is
# 'align', as we're really only interested in log messages that come
# from the pipeline itself.

# This is a bit lame, but I'm not sure else to do it. We want the log
# files to go in the output directory, but we need to initialize the
# logging system before we 'use' any RUM modules, since they get their
# logger statically.

# If we're aligning, try to find the output directory specified on the
# command line and initialize the logging system so that it puts
# output files there.
if (@ARGV && $ARGV[0] eq 'align') {
    for (my $i = 0; $i < @ARGV; $i++) {
        local $_ = $ARGV[$i];
        if (/^(-o|--out)/) {
            RUM::Logging->init($ARGV[$i + 1]);
        }
    }
}

# Otherwise initialize it without an argument, which will cause it to
# suppress all logging.
RUM::Logging->init;

# We have to require and not use, as use happens at compile time,
# before logging is initialized.
require "RUM/Script.pm";
RUM::Script->run_with_logging("RUM::Script::Main");

=pod

=head1 NAME

rum_runner - RNA-Seq Unified Mapper

=head1 SYNOPSIS

  rum_runner align   -o dir [OPTIONS] [FORWARD [REVERSE]]
  rum_runner clean   -o dir [--very]
  rum_runner kill    -o dir
  rum_runner status  -o dir
  rum_runner version
  rum_runner help    [ACTION]

=head1 DESCRIPTION

Use this program to run the RUM pipeline, as well as to do things like
check the status of a job, kill a job, and clean up after a job.

Every time you run rum_runner you must give it an action that tells it
what to do. When you run the pipeline using C<rum_runner align>,
rum_runner puts all of its output files in one directory, specified by
the B<-o> or B<--output> option. While the job is running you can
check the status by running C<rum_runner status -o I<dir>>, where
I<dir> is the output directory. You can kill it by running
C<rum_runner I<kill>> or C<rum_runner kill -o I<dir>>.

B<Note>: Please run C<rum_runner help align> to see all of the options
you can use when running an alignment.

=head1 OPTIONS

=head2 Actions

These commands tell rum_runner what to do.

=over 4

=item B<align>

Run the RUM pipeline.

=item B<clean>

Delete intermediate files in the specified output directory. 

=item B<kill>

Attempt to kill the job running in the specified output
directory. Note that if you're running a job in a terminal you also
kill it using CTRL-C.

=item B<status>

Check the status of a job running in the output directory specified by
-o or --output.

=item B<version>

Print out the version of RUM.

=item B<help> [I<action>]

Print usage information. If I<action> is provided, print help
information specific to that action.

=back

=head1 SEE ALSO

L<rum_runner/align>, L<rum_runner/clean>, L<rum_runner/kill>,
L<rum_runner/status>, L<rum_runner/version>

=cut

=head1 AUTHORS

Gregory Grant (ggrant@grant.org)

Mike DeLaurentis (delaurentis@gmail.com)

=head1 COPYRIGHT

Copyright 2012, University of Pennsylvania

=cut
