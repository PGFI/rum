#!/usr/bin/env perl

BEGIN {

    my @modules = qw(autodie);
    my %errors;
    for my $module (@modules) {
        my $file = $module . ".pm";
        $file =~ s/::/\//g;

        eval {
            require $file;
        };
        if ($@) {
            warn "$@\n";
            $errors{$module} = $@;
        }
    }
    if (keys %errors) {
        my $msg = "";
        $msg .= "There were some dependencies I couldn't find.\n";
        $msg .= "Please make sure the following libraries are installed:\n";
        for my $error (keys %errors) {
            $msg .= "  * $error\n";
        }
        die "$msg\n";
    }
}


use strict;
use warnings;

use FindBin qw($Bin);
use lib ("$Bin/../lib", "$Bin/../lib/perl5");
use File::Path qw(rmtree);
use File::Spec qw(splitdir catfile);
use List::Util qw(first);
use RUM::Logging;

sub archive_log_dir {
    
    my ($dir) = @_;

    my $log_dir = RUM::Logging->log_dir_for_output_dir($dir);
    return if ! -d $log_dir;

    my $timestamp = scalar time;
    my $child_dir = "log.$timestamp";
    my $tarred    = "log.$timestamp.tar";
    my $zipped    = "log.$timestamp.tar";

    my $status;
    
    print "Archiving log directory $log_dir to $zipped\n";
    
    $status = system 'mv', $log_dir, "$dir/$child_dir";
    if ( $status ) {
        warn "Can't move log directory to $dir/$child_dir";
        return;
    }
    
    $status = system "tar cf $dir/$tarred -C $dir $child_dir";
    if ( $status ) {
        warn "Can't tar log directory $dir/$child_dir";
        return;
    }
    
    $status = system "gzip $dir/$tarred";
    if ( $status ) {
        warn "Can't gzip log archive $dir/$tarred";
        return;
    }
}

# Initialize the logging system. We only want to log if the action is
# 'align', as we're really only interested in log messages that come
# from the pipeline itself.

# This is a bit lame, but I'm not sure else to do it. We want the log
# files to go in the output directory, but we need to initialize the
# logging system before we 'use' any RUM modules, since they get their
# logger statically.

# If we're aligning, try to find the output directory specified on the
# command line and initialize the logging system so that it puts
# output files there.
if (@ARGV && $ARGV[0] =~ /^(init|align|resume)$/) {

    my $is_top_level = ! first { / ^ (--parent | --child) $ /mx } @ARGV;

    for (my $i = 0; $i < @ARGV; $i++) {
        if ($ARGV[$i] =~ /^(-o|--out)/) {
            if ($is_top_level) {
                archive_log_dir($ARGV[$i + 1]);
            }
            RUM::Logging->init($ARGV[$i + 1]);
        }
    }
}

# Otherwise initialize it without an argument, which will cause it to
# suppress all logging.
RUM::Logging->init;

# We have to require and not use, as use happens at compile time,
# before logging is initialized.
require "RUM/Script/Main.pm";
RUM::Script::Main->main;
