#!/usr/bin/env perl

use strict;
use warnings;

use Test::More tests => 15;

use lib "lib";
use Log::Log4perl qw(:easy);
Log::Log4perl->easy_init($WARN);
use RUM::Config qw(parse_organisms format_config);
use RUM::Rule::Engine qw(report satisfy_with_command chain);
use Carp;

use Getopt::Long;

################################################################################
###
### Configuration
###

my %BIN_TARBALLS = (
    "linux" =>  "http://itmat.rum.s3.amazonaws.com/bin_linux64.tar",
    "darwin" => "http://itmat.rum.s3.amazonaws.com/bin_mac1.5.tar"
);

my $ROOT = "_testing";

my $TEST_DATA_URL = "http://pgfi.rum.s3.amazonaws.com/rum-test-data.tar.gz";
my $ORGANISMS_URL = "http://itmat.rum.s3.amazonaws.com/organisms.txt",

# Locations of input files and dirs
my $TEST_INDEX_DIR      = "$ROOT/indexes";
my $TEST_DATA_TARBALL   = "$ROOT/rum-test-data.tar.gz";
my $RESOURCES_DIR       = "$ROOT/rum-test-data";
my $ORGANISMS_FILE      = "$ROOT/organisms.txt";
my $TEST_SCRIPT_DIR     = "orig/scripts";
my $TEST_LIB_DIR        = "orig/lib";

my $BIN_TARBALL         = "$ROOT/bin_tarball.tar";
my $BIN_TARBALL_URL     = $BIN_TARBALLS{$^O}
    or die "I don't have a tarball of binaries for OS $^O";
my $BIN_DIR             = "$ROOT/bin";

# These files are produced by Rum
my @RUM_OUTPUT_FILES = qw(PostProcessing-errorlog        
                          junctions_all.rum
                          RUM.sam
                          junctions_high-quality.bed
                          RUM_NU
                          mapping_stats.txt
                          RUM_NU.cov
                          RUM_NU.sorted
                          reads.fa
                          RUM_Unique
                          restart.ids
                          RUM_Unique.cov
                          RUM_Unique.sorted
                          feature_quantifications_Lane1
                          junctions_all.bed
                     );

# Rum produces these files too, but we don't compare them to the
# expected output because they're too variable.
my @IGNORED_RUM_OUTPUT_FILES = qw(rum.log_chunk.1
                                  rum.error-log
                                  postprocessing_Lane1.log
                                  rum.log_master);

my %CONFIG_DEFAULTS = (
    "bowtie-bin" => "$BIN_DIR/bowtie",
    "blat-bin"   => "$BIN_DIR/blat",
    "mdust-bin"  => "$BIN_DIR/mdust",
    "script-dir" => $TEST_SCRIPT_DIR,
    "lib-dir"    => $TEST_LIB_DIR);

my %CONFIGS = (
    "mouse" => {
        
        "rum_config" => {
            "gene-annotation-file" => "$TEST_INDEX_DIR/mm9_refseq_ucsc_vega_gene_info.txt",
            "bowtie-genome-index"  => "$TEST_INDEX_DIR/mm9_genome",
            "bowtie-gene-index"    => "$TEST_INDEX_DIR/mm9_genes",
            "blat-genome-index"    => "$TEST_INDEX_DIR/mm9_genome_one-line-seqs.fa"},

        genome_build => "mm9" ,
        input_file => "$RESOURCES_DIR/test_mouse/s_1_1.baby",
        rum_config_file => "$ROOT/rum.config_mm9"
    }
);

################################################################################
###
### Helper functions for getting configuration settings
###

sub expected_output_dir {
    my ($test_name) = @_;
    return "$RESOURCES_DIR/${test_name}-expected";
}

sub output_data_dir {
    my ($test_name) = @_;
    return "$ROOT/data/$test_name/Lane1";
}

sub config {
    my $test_name = shift 
        or croak "I need a test name to get the config";
    my $config = $CONFIGS{$test_name} 
        or croak "I don't have a configuration for $test_name";
}

sub input_file {
    my ($test_name) = @_;
    return config($test_name)->{input_file};
}

sub rum_config_file {
    my ($test_name) = @_;
    return config($test_name)->{rum_config_file};
}

################################################################################
###
### Rules
###

my $engine = RUM::Rule::Engine->new;

my $paths_exist = $engine->rule(
    name => "Make paths",
    depends_on => sub {
        my ($options, $run_name) = @_;
        print "Run name is $run_name\n";
        return [$engine->make_path_rule(expected_output_dir($run_name)),
                $engine->make_path_rule(output_data_dir($run_name))]
    });

# This rule downloads the organisms text file to the current directory
my $have_organisms_txt = $engine->download_rule($ORGANISMS_URL, $ORGANISMS_FILE);

my $have_indexes = $engine->rule(
    name => "Download indexes",
    action => sub {
        my ($options, $run_name) = @_;

        my $build_name = config($run_name)->{genome_build}
            or croak "I don't have a genome build id for run name $run_name";

        report "Parsing organisms file";
        open my $orgs, "<", $ORGANISMS_FILE;
        my @organisms = parse_organisms($orgs) 
            or croak "I can't parse the organisms file";
        
        # Filter the organisms to include only mouse
        @organisms = grep {$_->{build} eq $build_name} @organisms;
        
        # Get all the URLs listed for any orgs we're interested in
        my @urls = map { @{ $_->{files} } } @organisms;
        
        # For each of the URLs, enqueue a rule that will download it
        for my $url (@urls) {
            my $file = $TEST_INDEX_DIR . "/" .
                substr($url, rindex($url, "/") + 1);
            if ($file =~ /^(.*)\.gz$/) {
                my $unzipped = $1;
                push @{ $engine->queue }, ($engine->rule(
                    name => "Download and unzip $file",
                    target => sub { -f $unzipped },
                    action => chain(
                        sub {
                            my $ua = LWP::UserAgent->new;
                            $ua->get($url, ":content_file" => $file);
                        },
                        satisfy_with_command("gunzip", $file))));
            }
            else {
                push @{ $engine->queue }, $engine->download_rule($url, $file);
            }
        }
    },
    depends_on => [$engine->make_path_rule($TEST_INDEX_DIR),
                   $have_organisms_txt]);

my $have_config_file = $engine->rule(
    name => "Make config file",
    target => sub { 
        my ($options, $run_name) = @_;
        my $filename = rum_config_file($run_name);
        report "Looking for config file $filename";
        -f $filename;
    },
    action => sub {
        my ($options, $run_name) = @_;
        my $filename = rum_config_file($run_name);
        report "Writing config file to $filename";
        open my $out, ">", $filename;
        my %config = %CONFIG_DEFAULTS;
        my %custom = %{ config($run_name)->{rum_config} };
        @config{keys(%custom)} = values(%custom);
        print $out format_config(%config);
    },
    depends_on => [$paths_exist]);

my $have_test_data_tarball = $engine->download_rule(
    $TEST_DATA_URL, $TEST_DATA_TARBALL,
    depends_on => [$paths_exist]);

my $have_bin_tarball = $engine->download_rule(
    $BIN_TARBALL_URL, $BIN_TARBALL,
    depends_on => [$paths_exist]);

my $have_bins = $engine->rule(
    name => "Untar binaries",
    target => sub {
        my @bins = @CONFIG_DEFAULTS{qw(bowtie-bin blat-bin mdust-bin)};
        not grep { not -f $_ } @bins;
    },
    action => satisfy_with_command("tar", "-xvf", $BIN_TARBALL, "-C", $ROOT),
    depends_on => [$have_bin_tarball]);

my $have_test_data = $engine->rule(
    name => "Untar test data",
    target => sub { 
        my ($options, $run_name) = @_;
        print "Got run name $run_name\n";
        -f $CONFIGS{$run_name}->{input_file} 
    },
    action => satisfy_with_command("tar", "-zxvf", $TEST_DATA_TARBALL, "-C", $ROOT),
    depends_on => [$have_test_data_tarball]);

sub all_output_files_exist_in_dir {
    return not grep { not -f "$_[0]/$_" } @RUM_OUTPUT_FILES;
}

my $have_rum_output = $engine->rule(
    name => sub { "Run RUM for $_[1]" },
    target => sub { 
        my ($options, $run_name) = @_;
        return all_output_files_exist_in_dir(output_data_dir($run_name)) 
    },
    action => sub {
        my ($options, $run_name) = @_;
        my @cmd = ("perl", "orig/RUM_runner.pl",
                   rum_config_file($run_name),
                   input_file($run_name),
                   output_data_dir($run_name),
                   "1", 
                   "Lane1");
        if ($options->{dry_run}) {
            print "@cmd\n";
        }
        else {
            system(@cmd) == 0 or croak "Can't execute @cmd: $!";
        }
    },
    depends_on => [$have_indexes,
                   $have_config_file,
                   $have_test_data,
                   $have_bins]);

sub diff_cmd {
    my ($test_name, $file) = @_;
    my $expected_dir = expected_output_dir($test_name);
    my $output_dir   = output_data_dir($test_name);
    return "diff $expected_dir/$file $output_dir/$file";
}

my $compare_output_to_expected = $engine->rule(
    name   => "Compare Rum output to expected output",
    target => sub { -f "diff.out" },
    action => sub {
        my ($options, $run_name) = @_;
        print "Run name is $run_name\n";
        local $_;
        for my $file (@RUM_OUTPUT_FILES) {
            my $cmd = diff_cmd($run_name, $file);
            if ($options->{dry_run}) {
                print "$cmd\n";
            }
            else {
                open my $pipe, "$cmd |" or croak "Couldn't open $cmd";
                my $diffs = 0;
                while (defined (local $_ = <$pipe>)) {
                    $diffs++;
                    print;
                }
                is($diffs, 0, "No diffs for $file");
            }
        }
    },
    depends_on => [$have_test_data, $have_rum_output]);

sub main {

    GetOptions(
        "dry-run|n" => \(my $dry_run),
        "verbose|v" => \(my $verbose));

    $engine->verbose($verbose);
    $engine->dry_run($dry_run);
    $engine->enqueue($compare_output_to_expected);
    $engine->build("mouse");
}

main();
