#!/usr/bin/env perl

use strict;
use warnings;

use Test::More tests => 15;
use FindBin qw($Bin);
use lib "$Bin/../lib";
use Log::Log4perl qw(:easy);
Log::Log4perl->easy_init($WARN);
use RUM::Config qw(parse_organisms format_config);
use RUM::Workflow qw(make_paths shell report is_dry_run with_settings);
use Carp;
use Getopt::Long;

################################################################################
###
### Configuration
###

my %BIN_TARBALLS = (
    "linux" =>  "http://itmat.rum.s3.amazonaws.com/bin_linux64.tar",
    "darwin" => "http://itmat.rum.s3.amazonaws.com/bin_mac1.5.tar"
);

my $ROOT = "$Bin/../_testing";

my $TEST_DATA_URL = "http://pgfi.rum.s3.amazonaws.com/rum-test-data.tar.gz";
my $ORGANISMS_URL = "http://itmat.rum.s3.amazonaws.com/organisms.txt",

# Locations of input files and dirs
my $TEST_INDEX_DIR      = "$ROOT/indexes";
my $TEST_DATA_TARBALL   = "$ROOT/rum-test-data.tar.gz";
my $RESOURCES_DIR       = "$ROOT/rum-test-data";
my $ORGANISMS_FILE      = "$ROOT/organisms.txt";
my $TEST_SCRIPT_DIR     = "$Bin/../orig/scripts";
my $TEST_LIB_DIR        = "$Bin/../orig/lib";

my $BIN_TARBALL         = "$ROOT/bin_tarball.tar";
my $BIN_TARBALL_URL     = $BIN_TARBALLS{$^O}
    or die "I don't have a tarball of binaries for OS $^O";
my $BIN_DIR             = "$ROOT/bin";

# These files are produced by Rum
my @RUM_OUTPUT_FILES = qw(PostProcessing-errorlog        
                          junctions_all.rum
                          RUM.sam
                          junctions_high-quality.bed
                          RUM_NU
                          mapping_stats.txt
                          RUM_NU.cov
                          RUM_NU.sorted
                          reads.fa
                          RUM_Unique
                          restart.ids
                          RUM_Unique.cov
                          RUM_Unique.sorted
                          feature_quantifications_Lane1
                          junctions_all.bed
                     );

# Rum produces these files too, but we don't compare them to the
# expected output because they're too variable.
my @IGNORED_RUM_OUTPUT_FILES = qw(rum.log_chunk.1
                                  rum.error-log
                                  postprocessing_Lane1.log
                                  rum.log_master);

my %CONFIG_DEFAULTS = (
    "bowtie-bin" => "$BIN_DIR/bowtie",
    "blat-bin"   => "$BIN_DIR/blat",
    "mdust-bin"  => "$BIN_DIR/mdust",
    "script-dir" => $TEST_SCRIPT_DIR,
    "lib-dir"    => $TEST_LIB_DIR);

our @BINARIES = @CONFIG_DEFAULTS{qw(bowtie-bin blat-bin mdust-bin)},

my %CONFIGS = (
    "mouse-baby" => {
        
        "rum_config" => {
            "gene-annotation-file" => "$TEST_INDEX_DIR/mm9_refseq_ucsc_vega_gene_info.txt",
            "bowtie-genome-index"  => "$TEST_INDEX_DIR/mm9_genome",
            "bowtie-gene-index"    => "$TEST_INDEX_DIR/mm9_genes",
            "blat-genome-index"    => "$TEST_INDEX_DIR/mm9_genome_one-line-seqs.fa"},

        genome_build => "mm9" ,
        rum_config_file => "$ROOT/rum.config_mm9",
        input_files => ["$RESOURCES_DIR/test_mouse/s_1_1.baby",
                        "$RESOURCES_DIR/test_mouse/s_1_2.baby"],
        expected_output_dir => "$RESOURCES_DIR/mouse-baby"
    },

    "mouse-baby-grid" => {
        
        "rum_config" => {
            "gene-annotation-file" => "$TEST_INDEX_DIR/mm9_refseq_ucsc_vega_gene_info.txt",
            "bowtie-genome-index"  => "$TEST_INDEX_DIR/mm9_genome",
            "bowtie-gene-index"    => "$TEST_INDEX_DIR/mm9_genes",
            "blat-genome-index"    => "$TEST_INDEX_DIR/mm9_genome_one-line-seqs.fa"},

        genome_build => "mm9" ,
        rum_config_file => "$ROOT/rum.config_mm9",
        input_files => ["$RESOURCES_DIR/test_mouse/s_1_1.baby",
                        "$RESOURCES_DIR/test_mouse/s_1_2.baby"],

        rum_options => ["-qsub"],
        expected_output_dir => "$RESOURCES_DIR/mouse-baby"
    }
);


################################################################################
###
### Helper functions for getting configuration settings
###

sub expected_output_dir {
    my ($test_name) = @_;
    return config($test_name)->{expected_output_dir};
}

sub output_data_dir {
    my ($test_name) = @_;
    croak "Can't get output data dir without test name" unless $test_name;
    return "$ROOT/data/$test_name/Lane1";
}

sub config {
    my $test_name = shift 
        or confess "I need a test name to get the config";
    my $config = $CONFIGS{$test_name} 
        or confess "I don't have a configuration for $test_name";
}

sub input_files {
    my ($test_name) = @_;
    return @{ config($test_name)->{input_files} };
}

sub rum_config_file {
    my ($test_name) = @_;
    return config($test_name)->{rum_config_file};
}

sub rum_options {
    my ($test_name) = @_;
    return config($test_name)->{rum_options} || [];
}


=head2 Actions

All these functions should respect the $DRY_RUN flag and not perform
any actions if it is set to a true value.

=cut

sub make_test_paths {
    my ($run_name) = @_;
    my @paths = (expected_output_dir($run_name),
                 output_data_dir($run_name),
                 $TEST_INDEX_DIR);
    make_paths(@paths);
}



=item download_file URL, LOCAL

Download URL and save it with the given LOCAL filename, unless LOCAL
already exists or $DRY_RUN is set.

=cut

sub download_file {
    my ($url, $local) = @_;
    if (-e $local) {
        print "$local exists, skipping\n";
        return;
    }
    report "Download $url to $local";
    unless (is_dry_run) {
        my $ua = LWP::UserAgent->new;
        $ua->get($url, ":content_file" => $local);
    }
}

=item download_test_data

Download the test data tarball and unpack it, unless it already
exists or $DRY_RUN is set.

=cut

sub download_test_data {
    download_file($TEST_DATA_URL, $TEST_DATA_TARBALL);
    report "Unpack test tarball";
    shell("tar", "-zxvf", $TEST_DATA_TARBALL, "-C", $ROOT) unless is_dry_run;
}

=item download_test_data

Download the binary tarball and unpack it, unless it already
exists or $DRY_RUN is set.

=cut

sub download_bin_tarball {
    download_file($BIN_TARBALL_URL, $BIN_TARBALL);
    report "Untar binaries";
    shell("tar", "-xvf", $BIN_TARBALL, "-C", $ROOT) unless is_dry_run;
}

=item get_indexes RUN_NAME

Get all the indexes required for RUN_NAME, unless we already have them
or $DRY_RUN is set.

=cut

sub get_indexes {
    my ($run_name) = @_;

    download_file($ORGANISMS_URL, $ORGANISMS_FILE);

    my $build_name = config($run_name)->{genome_build}
        or croak "I don't have a genome build id for run name $run_name";
    
    report "Parse organisms file";
    open my $orgs, "<", $ORGANISMS_FILE;
    my @organisms = parse_organisms($orgs) 
        or croak "I can't parse the organisms file";
    
    # Filter the organisms to include only mouse
    @organisms = grep {$_->{build} eq $build_name} @organisms;
    
    # Get all the URLs listed for any orgs we're interested in
    my @urls = map { @{ $_->{files} } } @organisms;
    
    # For each of the URLs, enqueue a rule that will download it
    for my $url (@urls) {
        my $file = $TEST_INDEX_DIR . "/" .
            substr($url, rindex($url, "/") + 1);
        if ($file =~ /^(.*)\.gz$/) {
            my $unzipped = $1;
            if (-e $unzipped) {
                report "$unzipped exists; not downloading or unzipping";
            }
            else {
                download_file($url, $file) unless -e $unzipped;
                shell("gunzip", $file) unless is_dry_run;
            }
        }
        else {
            download_file($url, $file);
        }
    }
}


=item MAKE_CONFIG_FILE

Make the RUM config file for the given run name unless it already
exists or $DRY_RUN is set.

=cut

sub make_config_file { 
    my ($run_name) = @_;
    my $filename = rum_config_file($run_name);

    if (-e $filename) {
        report "$filename exists, skipping";
    }
    report "Write config file to $filename";
    return if is_dry_run;
    open my $out, ">", $filename;
    my %config = %CONFIG_DEFAULTS;
    my %custom = %{ config($run_name)->{rum_config} };
    @config{keys(%custom)} = values(%custom);
    print $out format_config(%config);   
}

=item run_rum RUN_NAME

Run RUM with the appropriate parameters for the given RUN_NAME, unless
all the run output already exists or $DRY_RUN is set.

=cut

sub run_rum {
    my ($run_name) = @_;

    my $output_dir = output_data_dir($run_name);
    my @output = map "$output_dir/$_", @RUM_OUTPUT_FILES;
    unless (grep { not -e } @output) {
        report "All RUM output exists, skipping";
        return;
    }

    make_test_paths($run_name);
    get_indexes($run_name);
    make_config_file($run_name);
    download_bin_tarball($run_name);
    download_test_data($run_name);

    my @cmd = ("perl", "orig/RUM_runner.pl",
               rum_config_file($run_name),
               join(",,,", input_files($run_name)),
               output_data_dir($run_name),
               "1", 
               "Lane1", @{ rum_options($run_name) });
    (system(@cmd) == 0 or croak "Can't execute @cmd: $!")
        unless is_dry_run
}

=item compare_rum_output RUN_NAME

Compare the RUM output for the given test run name against what we
expect. This will cause the tests to fail if there are any
differences.

=cut

sub compare_rum_output {
    my ($run_name) = @_;
    run_rum($run_name);
    my $expected_dir = expected_output_dir($run_name);
    my $output_dir   = output_data_dir($run_name);
    open my $out, "$run_name.diff";
    for my $file (@RUM_OUTPUT_FILES) {
        my $cmd = "diff $expected_dir/$file $output_dir/$file";
        print "$cmd\n";
        unless (is_dry_run) {
            open my $pipe, "$cmd |" or croak "Couldn't open $cmd";
            my $diffs = 0;
            while (defined (local $_ = <$pipe>)) {
                $diffs++;
                print $out $_;
            }
            is($diffs, 0, "No diffs for $file");
        }
    }
}

sub main {

    GetOptions(
        "dry-run|n" => \(my $dry_run),
        "verbose|v" => \(my $verbose));

    my (@run_names) = @ARGV;

    for my $run_name (@run_names) {
        with_settings({dry_run => $dry_run},
                      sub {
                          compare_rum_output($run_name)
                      });
    }
}
main();
