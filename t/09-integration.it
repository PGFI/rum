#!/usr/bin/env perl

use strict;
use warnings;

use Test::More tests => 30;
use FindBin qw($Bin);
use lib "$Bin/../lib";
use Log::Log4perl qw(:easy);
use RUM::Config;
use RUM::Workflow qw(make_paths shell report is_dry_run with_settings is_on_cluster);
use RUM::TestUtils qw(download_file download_test_data);
use RUM::Repository;
use Carp;
use Getopt::Long;

Log::Log4perl->easy_init($WARN);

################################################################################
###
### Configuration
###

my $ROOT = "$Bin/../_testing";

my $repo = RUM::Repository->new(root_dir => $ROOT)->setup;

my $TEST_DATA_URL = "http://pgfi.rum.s3.amazonaws.com/rum-test-data.tar.gz";

# Locations of input files and dirs
my $TEST_DATA_TARBALL   = "$ROOT/rum-test-data.tar.gz";
my $RESOURCES_DIR       = "$ROOT/rum-test-data";

# These files are produced by Rum
my @RUM_OUTPUT_FILES = qw(PostProcessing-errorlog        
                          junctions_all.rum
                          RUM.sam
                          junctions_high-quality.bed
                          RUM_NU
                          mapping_stats.txt
                          RUM_NU.cov
                          RUM_NU.sorted
                          reads.fa
                          RUM_Unique
                          restart.ids
                          RUM_Unique.cov
                          RUM_Unique.sorted
                          feature_quantifications_Lane1
                          junctions_all.bed
                     );

# Rum produces these files too, but we don't compare them to the
# expected output because they're too variable.
my @IGNORED_RUM_OUTPUT_FILES = qw(rum.log_chunk.1
                                  rum.error-log
                                  postprocessing_Lane1.log
                                  rum.log_master);

my %CONFIGS = (
    "mouse-baby" => {
        
        genome_build => "mm9" ,
        input_files => ["$RESOURCES_DIR/test_mouse/s_1_1.baby",
                        "$RESOURCES_DIR/test_mouse/s_1_2.baby"],
        expected_output_dir => "$RESOURCES_DIR/mouse-baby",
        rum_options => ["-noclean"],
        needs_cluster => 0
    },

    "mouse-baby-split" => {
        
        genome_build => "mm9" ,
        input_files => ["$RESOURCES_DIR/test_mouse/s_1_1.baby",
                        "$RESOURCES_DIR/test_mouse/s_1_2.baby"],
        expected_output_dir => "$RESOURCES_DIR/mouse-baby",
        rum_options => ["-noclean"],
        chunks => 2,
        needs_cluster => 0
    },

    "mouse-baby-grid" => {
        
        genome_build => "mm9" ,
        input_files => ["$RESOURCES_DIR/test_mouse/s_1_1.baby",
                        "$RESOURCES_DIR/test_mouse/s_1_2.baby"],
        rum_options => ["-qsub", "-noclean"],
        expected_output_dir => "$RESOURCES_DIR/mouse-baby",
        needs_cluster => 1
    }
);


###############################################################################
###
### Helper functions for getting configuration settings
###

sub expected_output_dir {
    my ($test_name) = @_;
    return config($test_name)->{expected_output_dir};
}

sub output_data_dir {
    my ($test_name) = @_;
    croak "Can't get output data dir without test name" unless $test_name;
    return "$ROOT/data/$test_name/Lane1";
}

sub config {
    my $test_name = shift 
        or confess "I need a test name to get the config";
    my $config = $CONFIGS{$test_name} 
        or confess "I don't have a configuration for $test_name";
}

sub input_files {
    my ($test_name) = @_;
    return @{ config($test_name)->{input_files} };
}

sub rum_options {
    my ($test_name) = @_;
    return config($test_name)->{rum_options} || [];
}

sub chunks {
    my ($test_name) = @_;
    return config($test_name)->{chunks} || 1;
}

=head2 Actions

All these functions should respect the $DRY_RUN flag and not perform
any actions if it is set to a true value.

=cut

sub make_test_paths {
    my ($run_name) = @_;
    my @paths = (expected_output_dir($run_name),
                 output_data_dir($run_name));
    make_paths(@paths);
}

sub find_index {
    my ($run_name) = @_;
    my $build_name = config($run_name)->{genome_build}
        or croak "I don't have a genome build id for run name $run_name";

    my @indexes = grep { $_->build eq $build_name } $repo->indexes();

    croak "I didn't find exactly one index" unless @indexes == 1;
    return $indexes[0];
}

=item run_rum RUN_NAME

Run RUM with the appropriate parameters for the given RUN_NAME, unless
all the run output already exists or $DRY_RUN is set.

=cut

sub run_rum {
    my ($run_name) = @_;

    my $output_dir = output_data_dir($run_name);
    my @output = map "$output_dir/$_", @RUM_OUTPUT_FILES;
    unless (grep { not -e } @output) {
        report "All RUM output exists, skipping";
        return;
    }

    make_test_paths($run_name);
    download_test_data($TEST_DATA_TARBALL);

    my $index = find_index($run_name);
    $repo->install_index($index) unless $repo->has_index($index);
    my $config = $repo->config_filename($index);
    $repo->fetch_binaries;

    my $inputs = join(",,,", input_files($run_name));
    my $out_dir = output_data_dir($run_name);
    my $chunks = chunks($run_name);
    my $name = "Lane1";
    my @options = @{ rum_options($run_name) };

    shell("perl", "bin/RUM_runner.pl", 
          $config, $inputs, $out_dir, $chunks, $name, @options);
}

=item compare_rum_output RUN_NAME

Compare the RUM output for the given test run name against what we
expect. This will cause the tests to fail if there are any
differences.

=cut

sub compare_rum_output {
    my ($run_name) = @_;
    download_test_data($TEST_DATA_TARBALL);
    run_rum($run_name);
    my $expected_dir = expected_output_dir($run_name);
    my $output_dir   = output_data_dir($run_name);
    open my $out, ">", "$run_name.diff";
    for my $file (@RUM_OUTPUT_FILES) {
        my $expected = "$expected_dir/$file";
        my $got      =   "$output_dir/$file";
        my $cmd = "diff $expected $got";
        INFO "$cmd";
        unless (is_dry_run) {
            open my $pipe, "$cmd |" or croak "Couldn't open $cmd";
            my $diffs = 0;
            while (defined (local $_ = <$pipe>)) {
                $diffs++;
                print $out $_;
            }
            is(-s $got, -s $expected, "$file is the right size");
            is($diffs, 0, "No diffs for $file");
        }
    }
}

sub main {

    GetOptions(
        "dry-run|n" => \(my $dry_run),
        "verbose|v" => \(my $verbose));

    my (@run_names) = @ARGV;

    unless (@run_names) {
      @run_names = qw(mouse-baby
                      mouse-baby-grid
                      mouse-baby-split);
    }

    for my $run_name (@run_names) {
      SKIP: {
            if (config($run_name)->{needs_cluster} && !is_on_cluster) {
                skip "Not on the cluster", 15;
            }
            else {
                
                with_settings({dry_run => $dry_run},
                              sub {
                                  compare_rum_output($run_name)
                              });
            }
        }
    }
}
main();
