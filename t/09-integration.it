#!/usr/bin/env perl

use strict;
use warnings;

use Test::More tests => 15;
use FindBin qw($Bin);
use lib "$Bin/../lib";
use Log::Log4perl qw(:easy);
Log::Log4perl->easy_init($WARN);
use RUM::Config qw(parse_organisms format_config);
use RUM::Rule::Engine qw(report satisfy_with_command chain);
use Carp;

use Getopt::Long;

################################################################################
###
### Configuration
###

my %BIN_TARBALLS = (
    "linux" =>  "http://itmat.rum.s3.amazonaws.com/bin_linux64.tar",
    "darwin" => "http://itmat.rum.s3.amazonaws.com/bin_mac1.5.tar"
);

my $ROOT = "$Bin/../_testing";

my $TEST_DATA_URL = "http://pgfi.rum.s3.amazonaws.com/rum-test-data.tar.gz";
my $ORGANISMS_URL = "http://itmat.rum.s3.amazonaws.com/organisms.txt",

# Locations of input files and dirs
my $TEST_INDEX_DIR      = "$ROOT/indexes";
my $TEST_DATA_TARBALL   = "$ROOT/rum-test-data.tar.gz";
my $RESOURCES_DIR       = "$ROOT/rum-test-data";
my $ORGANISMS_FILE      = "$ROOT/organisms.txt";
my $TEST_SCRIPT_DIR     = "$Bin/../orig/scripts";
my $TEST_LIB_DIR        = "$Bin/../orig/lib";

my $BIN_TARBALL         = "$ROOT/bin_tarball.tar";
my $BIN_TARBALL_URL     = $BIN_TARBALLS{$^O}
    or die "I don't have a tarball of binaries for OS $^O";
my $BIN_DIR             = "$ROOT/bin";

# These files are produced by Rum
my @RUM_OUTPUT_FILES = qw(PostProcessing-errorlog        
                          junctions_all.rum
                          RUM.sam
                          junctions_high-quality.bed
                          RUM_NU
                          mapping_stats.txt
                          RUM_NU.cov
                          RUM_NU.sorted
                          reads.fa
                          RUM_Unique
                          restart.ids
                          RUM_Unique.cov
                          RUM_Unique.sorted
                          feature_quantifications_Lane1
                          junctions_all.bed
                     );

# Rum produces these files too, but we don't compare them to the
# expected output because they're too variable.
my @IGNORED_RUM_OUTPUT_FILES = qw(rum.log_chunk.1
                                  rum.error-log
                                  postprocessing_Lane1.log
                                  rum.log_master);

my %CONFIG_DEFAULTS = (
    "bowtie-bin" => "$BIN_DIR/bowtie",
    "blat-bin"   => "$BIN_DIR/blat",
    "mdust-bin"  => "$BIN_DIR/mdust",
    "script-dir" => $TEST_SCRIPT_DIR,
    "lib-dir"    => $TEST_LIB_DIR);

our @BINARIES = @CONFIG_DEFAULTS{qw(bowtie-bin blat-bin mdust-bin)},

my %CONFIGS = (
    "mouse-baby" => {
        
        "rum_config" => {
            "gene-annotation-file" => "$TEST_INDEX_DIR/mm9_refseq_ucsc_vega_gene_info.txt",
            "bowtie-genome-index"  => "$TEST_INDEX_DIR/mm9_genome",
            "bowtie-gene-index"    => "$TEST_INDEX_DIR/mm9_genes",
            "blat-genome-index"    => "$TEST_INDEX_DIR/mm9_genome_one-line-seqs.fa"},

        genome_build => "mm9" ,
        rum_config_file => "$ROOT/rum.config_mm9",
        input_files => ["$RESOURCES_DIR/test_mouse/s_1_1.baby",
                        "$RESOURCES_DIR/test_mouse/s_1_2.baby"],
        expected_output_dir => "$RESOURCES_DIR/mouse-baby"
    },

    "mouse-baby-qsub" => {
        
        "rum_config" => {
            "gene-annotation-file" => "$TEST_INDEX_DIR/mm9_refseq_ucsc_vega_gene_info.txt",
            "bowtie-genome-index"  => "$TEST_INDEX_DIR/mm9_genome",
            "bowtie-gene-index"    => "$TEST_INDEX_DIR/mm9_genes",
            "blat-genome-index"    => "$TEST_INDEX_DIR/mm9_genome_one-line-seqs.fa"},

        genome_build => "mm9" ,
        rum_config_file => "$ROOT/rum.config_mm9",
        input_files => ["$RESOURCES_DIR/test_mouse/s_1_1.baby",
                        "$RESOURCES_DIR/test_mouse/s_1_2.baby"],

        rum_options => ["-qsub"],
        expected_output_dir => "$RESOURCES_DIR/mouse-baby"
    }
);

################################################################################
###
### Helper functions for getting configuration settings
###

sub expected_output_dir {
    my ($test_name) = @_;
    return config($test_name)->{expected_output_dir};
}

sub output_data_dir {
    my ($test_name) = @_;
    return "$ROOT/data/$test_name/Lane1";
}

sub config {
    my $test_name = shift 
        or confess "I need a test name to get the config";
    my $config = $CONFIGS{$test_name} 
        or confess "I don't have a configuration for $test_name";
}

sub input_files {
    my ($test_name) = @_;
    return @{ config($test_name)->{input_files} };
}

sub rum_config_file {
    my ($test_name) = @_;
    return config($test_name)->{rum_config_file};
}

sub rum_options {
    my ($test_name) = @_;
    return config($test_name)->{rum_options} || [];
}

################################################################################
###
### Rules
###

my $engine = RUM::Rule::Engine->new;

sub my_paths {
    my ($engine, $run_name) = @_;
    return (expected_output_dir($run_name),
            output_data_dir($run_name),
            $TEST_INDEX_DIR);
}

sub my_test_data {
    my ($engine, $run_name) = @_;
    return @{ config($run_name)->{input_files} };
}

sub my_rum_output {
    my ($engine, $run_name) = @_;
    map { output_data_dir($run_name) . "/$_" } @RUM_OUTPUT_FILES;
}

sub my_expected_output {
    my ($engine, $run_name) = @_;
    map { expected_output_dir($run_name) . "/$_" } @RUM_OUTPUT_FILES;
}

# Add a rule to make whatever paths are required for a given test run
$engine->rule(
    name => "Make paths for test data",
    produces => \&my_paths,
    action => sub {
        $engine->make_paths(my_paths(@_));
    });

# Add a rule to download the organisms text file to the current directory
$engine->download_rule($ORGANISMS_URL, $ORGANISMS_FILE);

# Add a rule to parse the organisms.txt file and download all the
# index files listed inside it.
my $have_indexes = $engine->rule(
    name => "Download indexes",
    target => sub { undef },
    action => sub {
        my ($options, $run_name) = @_;

        my $build_name = config($run_name)->{genome_build}
            or croak "I don't have a genome build id for run name $run_name";

        report "Parse organisms file";
        open my $orgs, "<", $ORGANISMS_FILE;
        my @organisms = parse_organisms($orgs) 
            or croak "I can't parse the organisms file";
        
        # Filter the organisms to include only mouse
        @organisms = grep {$_->{build} eq $build_name} @organisms;
        
        # Get all the URLs listed for any orgs we're interested in
        my @urls = map { @{ $_->{files} } } @organisms;
        
        # For each of the URLs, enqueue a rule that will download it
        for my $url (@urls) {
            my $file = $TEST_INDEX_DIR . "/" .
                substr($url, rindex($url, "/") + 1);
            if ($file =~ /^(.*)\.gz$/) {
                my $unzipped = $1;
                push @{ $engine->queue }, ($engine->rule(
                    name => "Download and unzip $file",
                    produces => $unzipped,
                    action => chain(
                        sub {
                            my $ua = LWP::UserAgent->new;
                            $ua->get($url, ":content_file" => $file);
                        },
                        satisfy_with_command("gunzip", $file))));
            }
            else {
                push @{ $engine->queue }, $engine->download_rule($url, $file);
            }
        }
    },
    depends_on => [$ORGANISMS_FILE, $TEST_INDEX_DIR]);

# Add a rule to generate the config file
$engine->rule(
    name => "Make config file",
    produces => sub { 
        my ($options, $run_name) = @_;
        return rum_config_file($run_name);
    },
    action => sub {
        my ($options, $run_name) = @_;
        my $filename = rum_config_file($run_name);
        report "Write config file to $filename";
        open my $out, ">", $filename;
        my %config = %CONFIG_DEFAULTS;
        my %custom = %{ config($run_name)->{rum_config} };
        @config{keys(%custom)} = values(%custom);
        print $out format_config(%config);
    },
    depends_on => \&my_paths);

# Download the test data tarball
$engine->download_rule(
    $TEST_DATA_URL, $TEST_DATA_TARBALL,
    depends_on => \&my_paths);

# Download the binary tarball
$engine->download_rule(
    $BIN_TARBALL_URL, $BIN_TARBALL,
    depends_on => \&my_paths);

# Unpack the binary tarball
$engine->rule(
    name => "Untar binaries",
    produces => [@BINARIES],
    action => satisfy_with_command("tar", "-xvf", $BIN_TARBALL, "-C", $ROOT),
    depends_on => $BIN_TARBALL);

# Unpack the test data tarball
$engine->rule(
    name => "Untar test data",
    produces => sub { (my_test_data(@_), my_expected_output(@_)) },
    action => satisfy_with_command("tar", "-zxvf", $TEST_DATA_TARBALL, "-C", $ROOT),
    depends_on => $TEST_DATA_TARBALL);

# Add a rule to run rum
$engine->rule(
    name => sub { "Run RUM for $_[1]" },
    produces => \&my_rum_output,
    action => sub {
        my ($engine, $run_name) = @_;
        my @cmd = ("perl", "orig/RUM_runner.pl",
                   rum_config_file($run_name),
                   join(",,,", input_files($run_name)),
                   output_data_dir($run_name),
                   "1", 
                   "Lane1", @{ rum_options($run_name) });
        print "@cmd\n";
        (system(@cmd) == 0 or croak "Can't execute @cmd: $!")
            unless $engine->dry_run;
    },
    depends_on => sub {
        my ($engine, $run_name) = @_;
        return ($have_indexes,
                rum_config_file($run_name),
                my_test_data($engine, $run_name),
                @BINARIES);
        });

$engine->rule(
    name   => "Compare Rum output to expected output",
    produces => sub { "$_[1].diff" },
    action => sub {
        my ($engine, $run_name) = @_;
        my $expected_dir = expected_output_dir($run_name);
        my $output_dir   = output_data_dir($run_name);
        open my $out, "$run_name.diff";
        for my $file (@RUM_OUTPUT_FILES) {
            my $cmd = "diff $expected_dir/$file $output_dir/$file";
            print "$cmd\n";
            unless ($engine->dry_run) {
                open my $pipe, "$cmd |" or croak "Couldn't open $cmd";
                my $diffs = 0;
                while (defined (local $_ = <$pipe>)) {
                    $diffs++;
                    print $out $_;
                }
                is($diffs, 0, "No diffs for $file");
            }
        }
    },
    depends_on => sub {
        return (
            my_test_data(@_),
            my_rum_output(@_),
            my_expected_output(@_));
    });

our @TEST_RUN_NAMES = qw(mouse-baby mouse-baby-qsub);

$engine->rule(
    produces => [map("clean-$_", @TEST_RUN_NAMES)],
    name => sub { "Remove the RUM output data for $_[1]" },
    action => sub {
        my ($engine, $run_name) = @_;
        my $dir = output_data_dir($run_name);
        print "rm -r $dir\n";
        rmtree($dir) unless $engine->dry_run;
    });

$engine->rule(
    produces => "veryclean",
    name => "Remove all the integration test data",
    action => sub {
        my ($engine, $run_name) = @_;
        print "rm -r $ROOT";
        rmtree($ROOT) unless $engine->dry_run;
    });
    
sub main {

    GetOptions(
        "dry-run|n" => \(my $dry_run),
        "verbose|v" => \(my $verbose),
        "list|l"    => \(my $list_rules));

    my ($run_name, @targets) = @ARGV;

    @targets = ("$run_name.diff") unless @targets;
    
    if ($list_rules) {
        for my $rule (@{ $engine->{rules} }) {
            print "Name: ", $rule->name($engine, $run_name), "\n";
            print "Produces:\n";
            for my $product ($rule->products($engine, $run_name)) {
                print "  $product\n";
            }
            print "\n";
        }
        return;
    }
    
    $engine->verbose($verbose);
    $engine->dry_run($dry_run);
    $engine->enqueue(@targets);
    for my $t (@targets) {
        $engine->build($run_name);
    }
}

main();
