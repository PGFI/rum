#!/usr/bin/env perl

use strict;
use warnings;

use Test::More tests => 15;

use lib "lib";
use Log::Log4perl qw(:easy);
Log::Log4perl->easy_init($WARN);
use RUM::Config qw(parse_organisms format_config);
use RUM::Rule::Engine qw(report satisfy_with_command chain);
use Carp;

use Getopt::Long;

################################################################################
###
### Configuration
###

my %BIN_TARBALLS = (
    "linux" =>  "http://itmat.rum.s3.amazonaws.com/bin_linux64.tar",
    "darwin" => "http://itmat.rum.s3.amazonaws.com/bin_mac1.5.tar"
);

my $ROOT = "_testing";

my $TEST_DATA_URL = "http://pgfi.rum.s3.amazonaws.com/rum-test-data.tar.gz";
my $ORGANISMS_URL = "http://itmat.rum.s3.amazonaws.com/organisms.txt",

# Locations of input files and dirs
my $TEST_INDEX_DIR      = "$ROOT/indexes";
my $TEST_DATA_TARBALL   = "$ROOT/rum-test-data.tar.gz";
my $RESOURCES_DIR       = "$ROOT/rum-test-data";
my $ORGANISMS_FILE      = "$ROOT/organisms.txt";
my $TEST_SCRIPT_DIR     = "orig/scripts";
my $TEST_LIB_DIR        = "orig/lib";

my $BIN_TARBALL         = "$ROOT/bin_tarball.tar";
my $BIN_TARBALL_URL     = $BIN_TARBALLS{$^O}
    or die "I don't have a tarball of binaries for OS $^O";
my $BIN_DIR             = "$ROOT/bin";

# These files are produced by Rum
my @RUM_OUTPUT_FILES = qw(PostProcessing-errorlog        
                          junctions_all.rum
                          RUM.sam
                          junctions_high-quality.bed
                          RUM_NU
                          mapping_stats.txt
                          RUM_NU.cov
                          RUM_NU.sorted
                          reads.fa
                          RUM_Unique
                          restart.ids
                          RUM_Unique.cov
                          RUM_Unique.sorted
                          feature_quantifications_Lane1
                          junctions_all.bed
                     );

# Rum produces these files too, but we don't compare them to the
# expected output because they're too variable.
my @IGNORED_RUM_OUTPUT_FILES = qw(rum.log_chunk.1
                                  rum.error-log
                                  postprocessing_Lane1.log
                                  rum.log_master);

my %CONFIG_DEFAULTS = (
    "bowtie-bin" => "$BIN_DIR/bowtie",
    "blat-bin"   => "$BIN_DIR/blat",
    "mdust-bin"  => "$BIN_DIR/mdust",
    "script-dir" => $TEST_SCRIPT_DIR,
    "lib-dir"    => $TEST_LIB_DIR);
our @BINARIES = @CONFIG_DEFAULTS{qw(bowtie-bin blat-bin mdust-bin)},
my %CONFIGS = (
    "mouse" => {
        
        "rum_config" => {
            "gene-annotation-file" => "$TEST_INDEX_DIR/mm9_refseq_ucsc_vega_gene_info.txt",
            "bowtie-genome-index"  => "$TEST_INDEX_DIR/mm9_genome",
            "bowtie-gene-index"    => "$TEST_INDEX_DIR/mm9_genes",
            "blat-genome-index"    => "$TEST_INDEX_DIR/mm9_genome_one-line-seqs.fa"},

        genome_build => "mm9" ,
        input_file => "$RESOURCES_DIR/test_mouse/s_1_1.baby",
        rum_config_file => "$ROOT/rum.config_mm9"
    }
);

################################################################################
###
### Helper functions for getting configuration settings
###

sub expected_output_dir {
    my ($test_name) = @_;
    return "$RESOURCES_DIR/${test_name}-expected";
}

sub output_data_dir {
    my ($test_name) = @_;
    return "$ROOT/data/$test_name/Lane1";
}

sub config {
    my $test_name = shift 
        or confess "I need a test name to get the config";
    my $config = $CONFIGS{$test_name} 
        or confess "I don't have a configuration for $test_name";
}

sub input_file {
    my ($test_name) = @_;
    return config($test_name)->{input_file};
}

sub rum_config_file {
    my ($test_name) = @_;
    return config($test_name)->{rum_config_file};
}

################################################################################
###
### Rules
###

my $engine = RUM::Rule::Engine->new;

sub my_paths {
    my ($engine, $run_name) = @_;
    return (expected_output_dir($run_name),
            output_data_dir($run_name),
            $TEST_INDEX_DIR);
}

sub my_test_data {
    my ($engine, $run_name) = @_;
    return $CONFIGS{$run_name}->{input_file};
}

sub my_rum_output {
    my ($engine, $run_name) = @_;
    map { output_data_dir($run_name) . "/$_" } @RUM_OUTPUT_FILES;
}

sub my_expected_output {
    my ($engine, $run_name) = @_;
    map { expected_output_dir($run_name) . "/$_" } @RUM_OUTPUT_FILES;
}

# Add a rule to make whatever paths are required for a given test run
$engine->rule(
    produces => \&my_paths,
    action => sub {
        $engine->make_paths(my_paths(@_));
    });

# Add a rule to download the organisms text file to the current directory
$engine->download_rule($ORGANISMS_URL, $ORGANISMS_FILE);

# Add a rule to parse the organisms.txt file and download all the
# index files listed inside it.
my $have_indexes = $engine->rule(
    name => "Download indexes",
    target => sub { undef },
    action => sub {
        my ($options, $run_name) = @_;

        my $build_name = config($run_name)->{genome_build}
            or croak "I don't have a genome build id for run name $run_name";

        report "Parse organisms file";
        open my $orgs, "<", $ORGANISMS_FILE;
        my @organisms = parse_organisms($orgs) 
            or croak "I can't parse the organisms file";
        
        # Filter the organisms to include only mouse
        @organisms = grep {$_->{build} eq $build_name} @organisms;
        
        # Get all the URLs listed for any orgs we're interested in
        my @urls = map { @{ $_->{files} } } @organisms;
        
        # For each of the URLs, enqueue a rule that will download it
        for my $url (@urls) {
            my $file = $TEST_INDEX_DIR . "/" .
                substr($url, rindex($url, "/") + 1);
            if ($file =~ /^(.*)\.gz$/) {
                my $unzipped = $1;
                push @{ $engine->queue }, ($engine->rule(
                    name => "Download and unzip $file",
                    produces => $unzipped,
                    action => chain(
                        sub {
                            my $ua = LWP::UserAgent->new;
                            $ua->get($url, ":content_file" => $file);
                        },
                        satisfy_with_command("gunzip", $file))));
            }
            else {
                push @{ $engine->queue }, $engine->download_rule($url, $file);
            }
        }
    },
    depends_on => [$ORGANISMS_FILE, $TEST_INDEX_DIR]);

# Add a rule to generate the config file
$engine->rule(
    name => "Make config file",
    produces => sub { 
        my ($options, $run_name) = @_;
        return rum_config_file($run_name);
    },
    action => sub {
        my ($options, $run_name) = @_;
        my $filename = rum_config_file($run_name);
        report "Write config file to $filename";
        open my $out, ">", $filename;
        my %config = %CONFIG_DEFAULTS;
        my %custom = %{ config($run_name)->{rum_config} };
        @config{keys(%custom)} = values(%custom);
        print $out format_config(%config);
    },
    depends_on => \&my_paths);

# Download the test data tarball
$engine->download_rule(
    $TEST_DATA_URL, $TEST_DATA_TARBALL,
    depends_on => \&my_paths);

# Download the binary tarball
$engine->download_rule(
    $BIN_TARBALL_URL, $BIN_TARBALL,
    depends_on => \&my_paths);

# Unpack the binary tarball
$engine->rule(
    name => "Untar binaries",
    produces => [@BINARIES],
    action => satisfy_with_command("tar", "-xvf", $BIN_TARBALL, "-C", $ROOT),
    depends_on => $BIN_TARBALL);

# Unpack the test data tarball
$engine->rule(
    name => "Untar test data",
    produces => sub { (my_test_data(@_), my_expected_output(@_)) },
    action => satisfy_with_command("tar", "-zxvf", $TEST_DATA_TARBALL, "-C", $ROOT),
    depends_on => $TEST_DATA_TARBALL);

# Add a rule to run rum
$engine->rule(
    name => sub { "Run RUM for $_[1]" },
    produces => \&my_rum_output,
    action => sub {
        my ($engine, $run_name) = @_;
        my @cmd = ("perl", "orig/RUM_runner.pl",
                   rum_config_file($run_name),
                   input_file($run_name),
                   output_data_dir($run_name),
                   "1", 
                   "Lane1");
        print "@cmd\n";
        (system(@cmd) == 0 or croak "Can't execute @cmd: $!")
            unless $engine->dry_run;
    },
    depends_on => sub {
        my ($engine, $run_name) = @_;
        return ($have_indexes,
                rum_config_file($run_name),
                my_test_data($engine, $run_name),
                @BINARIES);
        });

sub diff_cmd {
    my ($test_name, $file) = @_;
    my $expected_dir = expected_output_dir($test_name);
    my $output_dir   = output_data_dir($test_name);
    return "diff $expected_dir/$file $output_dir/$file";
}

$engine->rule(
    name   => "Compare Rum output to expected output",
    produces => sub { "$_[1].diff" },
    action => sub {
        my ($engine, $run_name) = @_;
        open my $out, "$run_name.diff";
        for my $file (@RUM_OUTPUT_FILES) {
            my $cmd = diff_cmd($run_name, $file);
            print "$cmd\n";
            unless ($engine->dry_run) {
                open my $pipe, "$cmd |" or croak "Couldn't open $cmd";
                my $diffs = 0;
                while (defined (local $_ = <$pipe>)) {
                    $diffs++;
                    print $out $_;
                }
                is($diffs, 0, "No diffs for $file");
            }
        }
    },
    depends_on => sub {
        return (
            my_test_data(@_),
            my_rum_output(@_),
            my_expected_output(@_));
    });

sub main {

    GetOptions(
        "dry-run|n" => \(my $dry_run),
        "verbose|v" => \(my $verbose));

    my @targets = @ARGV;

    $engine->verbose($verbose);
    $engine->dry_run($dry_run);
    if (@targets) {
        $engine->enqueue(@targets);
    }
    else {
        $engine->enqueue("mouse.diff");
    }
    $engine->build("mouse");
}

main();
